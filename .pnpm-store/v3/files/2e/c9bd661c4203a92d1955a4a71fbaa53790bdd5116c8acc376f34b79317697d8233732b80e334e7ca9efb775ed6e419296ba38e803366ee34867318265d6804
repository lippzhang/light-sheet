"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@umijs/utils");
const fs_1 = __importDefault(require("fs"));
const loader_runner_1 = require("loader-runner");
const path_1 = __importDefault(require("path"));
const utils_2 = require("../../../utils");
const utils_3 = require("../../utils");
const dts_1 = require("../dts");
function replacePathExt(filePath, ext) {
    const parsed = path_1.default.parse(filePath);
    return path_1.default.join(parsed.dir, `${parsed.name}${ext}`);
}
function dealResult(result, args) {
    let fileDistAbsPath = args.opts.itemDistAbsPath;
    if (result) {
        // update ext if loader specified
        if (result.options.ext) {
            fileDistAbsPath = replacePathExt(args.opts.itemDistAbsPath, result.options.ext);
        }
        if (result.options.map) {
            const map = result.options.map;
            const mapLoc = `${fileDistAbsPath}.map`;
            fs_1.default.writeFileSync(mapLoc, map);
        }
        // distribute file with result
        fs_1.default.writeFileSync(fileDistAbsPath, result.content);
    }
    else {
        // copy file as normal assets
        fs_1.default.copyFileSync(args.fileAbsPath, fileDistAbsPath);
    }
    utils_2.logger.quietExpect.event(`Bundless ${utils_1.chalk.gray(path_1.default.basename(fileDistAbsPath))} to ${utils_1.chalk.gray(args.fileDistPath)}${(result === null || result === void 0 ? void 0 : result.options.declaration) ? ' (with declaration)' : ''}`);
    // prepare for declaration
    if (result.options.declaration) {
        // use winPath because ts compiler will convert to posix path
        return [(0, utils_1.winPath)(args.fileAbsPath), path_1.default.dirname(fileDistAbsPath)];
    }
}
/**
 * loader module base on webpack loader-runner
 */
exports.default = async (args) => {
    const cache = (0, utils_2.getCache)('bundless-loader');
    // format: {path:contenthash:config:pkgDeps}
    const cacheKey = [
        args.fileAbsPath,
        (0, utils_3.getContentHash)(fs_1.default.readFileSync(args.fileAbsPath, 'utf-8')),
        JSON.stringify(args.opts.config),
        // use for babel opts generator in src/builder/utils.ts
        JSON.stringify(Object.assign({}, args.opts.pkg.dependencies, args.opts.pkg.peerDependencies)),
    ].join(':');
    const cacheRet = await cache.get(cacheKey, '');
    // use cache first
    /* istanbul ignore if -- @preserve */
    if (cacheRet) {
        const tsconfig = /\.tsx?$/.test(args.fileAbsPath)
            ? (0, dts_1.getTsconfig)(args.opts.cwd)
            : undefined;
        const declaration = dealResult({
            ...cacheRet,
            options: {
                ...cacheRet.options,
                // FIXME: shit code for avoid invalid declaration value when tsconfig changed
                declaration: (tsconfig === null || tsconfig === void 0 ? void 0 : tsconfig.options.declaration) &&
                    (tsconfig === null || tsconfig === void 0 ? void 0 : tsconfig.fileNames.includes((0, utils_1.winPath)(args.fileAbsPath))),
            },
        }, args);
        return Promise.resolve(declaration);
    }
    // get matched loader by test
    const matched = args.loaders.find((item) => {
        switch (typeof item.test) {
            case 'string':
                return args.fileAbsPath.startsWith(item.test);
            case 'function':
                return item.test(args.fileAbsPath);
            default:
                // assume it is RegExp instance
                return item.test.test(args.fileAbsPath);
        }
    });
    if (matched) {
        // run matched loader
        return new Promise((resolve, reject) => {
            let outputOpts = {};
            (0, loader_runner_1.runLoaders)({
                resource: args.fileAbsPath,
                loaders: [{ loader: matched.loader, options: matched.options }],
                context: {
                    cwd: args.opts.cwd,
                    config: args.opts.config,
                    transformers: args.transformers,
                    pkg: args.opts.pkg,
                    itemDistAbsPath: args.opts.itemDistAbsPath,
                    setOutputOptions(opts) {
                        outputOpts = opts;
                    },
                },
                readResource: fs_1.default.readFile.bind(fs_1.default),
            }, (err, { result }) => {
                if (err) {
                    reject(err);
                }
                else if (result) {
                    // FIXME: handle buffer type?
                    const ret = {
                        content: result[0],
                        options: outputOpts,
                    };
                    // save cache then resolve
                    cache.set(cacheKey, ret).then(() => {
                        const declaration = dealResult(ret, args);
                        resolve(declaration);
                    });
                }
                else {
                    resolve(void 0);
                }
            });
        });
    }
    else {
        fs_1.default.copyFileSync(args.fileAbsPath, args.opts.itemDistAbsPath);
    }
};
